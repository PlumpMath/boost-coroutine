[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]

[section:generator Generator]

A __gen__ is a simple coroutine that can be used to control the iteration
behaviour of a loop. It generates a sequence of values, but instead of
returning them at once, a __gen__ behaves like an iterator yielding a values one
at the time if it is called.

Each instance of __gen__ represents a context (CPU registers and stack space) of
execution or __not_a_gen__. Objects of type __gen__ are moveable but not copyable
and can be returned by a function.

        boost::coro::generator< int > make_generator();

        void f()
        {
            boost::coro::generator< int > c( make_generator() );
            c();
        }

[note __boost_move__ is used to emulate rvalue references.]

[note If __fls__ is used on Windows, the user is responsible for calling 
__fls_alloc__, __fls_free__.]

[warning If __gen__ is used in a multithreaded application, it can
migrated between threads, but must not reference __tls__.]


[heading Executing a generator]

A new __gen__ is created from a callable object (known as the
__gen_fn__). The stack size, stack unwinding and floating-point
preserving behavior are determined by additional arguments.

The __gen__ constructor uses the __stack_allocator_concept__ from
__boost_context__ to allocate an associated stack, and the destructor uses the
same __stack_allocator_concept__ to deallocate the stack.  The default
__stack_allocator_concept__ is __stack_allocator__, but a custom stack-allocator
can be passed to the constructor (see documentation of __boost_context__).

The first argument of __gen_fn__  must be of type __gen_self__, used for yielding
the active generator.

        typedef boost::coro::generator< int > gen_t;

        void f( gen_t::self_t & self, int i)
        {
            ...
            self.yield();
            ...
        }

        gen_t g( boost::bind( f, _1, 7) );
        int y = g();

The __gen_fn__, as well as its arguments, if any, are copied into the
generator's state.  If a reference is required, use boost::ref.

Usally a __gen__ is called inside loops. The __gen_fn__ executed until
__gen_yield__ is called. The value passed to __gen_yield__ is used as the
generated value.
The next time the same __gen__ is called in a subsequent iteration, the
execution of the __gen_fn__ is resumed after __gen_yield__, until __gen_yield__
is called again.
__gen_fn__ can be terminated by __gen_yield_break__, at which time the loop
enclosing the __gen__ is terminated.

        typedef boost::coro::generator< int >    gen_t;

        int power( gen_t::self_t & self, int number, int exponent)
        {
            int counter = 0, result = 1;
            while ( counter++ < exponent)
            {
                result = result * number;
                self.yield( result);
            }
            self.yield_break();
        }

        int main()
        {
            {
                gen_t pw( boost::bind( power, _1, 2, 8) );
                while ( pw) {
                    std::cout << pw() <<  " ";
                }
            }

            std::cout << "\nDone" << std::endl;

            return EXIT_SUCCESS;
        }

        output:
            2 4 8 16 32 64 128 256
            Done


[note The maximum number of arguments of __gen_fn__ is 10.]

__gen_fn__ is invoked the first time inside the constructor of __gen__.
__gen_op__ can be called as long as __gen__ remains valid, e.g. __gen_eval__
returns `true`.
If __gen_fn__ can not return valid values anymore __gen_yield_break__ should be
called. This function returns the execution control back to the caller and sets
the __gen__ to be complete (`is_complete()` returns `true`). In this case
__gen_op__ does not throw an exception like __coro__. Of curse the __gen_fn__
can be exited with a `return` expression.

        typedef boost::coro::generator< int > gen_t;

        int fn( gen_t::self_t & self, int j)
        {
            for( int i = 0; i < j; ++i)
            {
                std::cout << "fn(): local variable i == " << i << std::endl;

                // save current generator
                // value of local variable is preserved
                // transfer execution control back to main()
                self.yield( i);

                // generator<>::operator()() was called
                // execution control transfered back from main()    
            }
            self.yield_break();
        }

        int main( int argc, char * argv[])
        {
            gen_t g( boost::bind( fn, _1, 7) );

            // yield was called so we returned
            while ( g)
            {
                // execution control is transfered to g
                int x = g();
                std::cout << "main(): generated == " << x << std::endl;

                // yield() was called within fn()
            }
            // yield_break() was called within fn()

            std::cout << "Done" << std::endl;

            return EXIT_SUCCESS;
        }

        output:
            fn(): local variable i == 0
            main(): generated == 0
            fn(): local variable i == 1
            main(): generated == 1
            fn(): local variable i == 2
            main(): generated == 2
            fn(): local variable i == 3
            main(): generated == 3
            fn(): local variable i == 4
            main(): generated == 4
            fn(): local variable i == 5
            main(): generated == 5
            fn(): local variable i == 6
            main(): generated == 6
            Done

[note In contrast to threads, which are preemtive, __gen__ switches are
cooperative (programmer controls when switch will happen). The kernel is not
involved in the generator switches.]

[warning Calling __gen_op__ from inside the same generator results in
undefined behaviour.]

[heading Exit a __gen_fn__]

__gen_yield_break__ does not take arguments and returns nothing, it leaves the
current __gen__ and jumps back to the calling routine. __gen_eval__ will return
`false`.

        typedef boost::coro::generator< int(int) > gen_t;

        int fn( coro_t::self_t & self, int a)
        {
            for ( int i = 0; i < a; ++i)
                self.yield( i);
            self.yield_break();
            return -1;
        }

        int main( int argc, char * argv[])
        {
            gen_t g( boost::bind( fn, _1, _2) );

            std::cout << "main(): call generator g" << std::endl;
            while ( g)
            {
                int res = g();
                std::cout << "main(): == " << res << std::endl;
            }

            std::cout << "Done" << std::endl;

            return EXIT_SUCCESS;
        }

        output:
            main(): call generator g
            main(): == 0
            main(): == 1
            main(): == 2
            Done

[important After calling __gen_yield_break__ the __gen__ is complete (can not
resumed with __gen_op__).]

[heading Exceptions in __gen_fn__]

An excepton thrown inside __gen_fn__ (transfered via exception-pointer - see
__boost_exception__ for details and requirements) will be re-thrown by __gen_op__.

[important Code executed by generator must not prevent the propagation of the
__forced_unwind__ exception.  Absorbing that exception will cause stack
unwinding to fail.  Thus, any code that catches all exceptions must rethrow the
pending exception.]

        try
        {
            // code that might throw
        }
        catch( forced_unwind)
        {
            throw;
        }
        catch(...)
        {
            // possibly not rethrow pending exception
        }


[heading Stack unwinding]

Sometimes it is necessary to unwind the stack of an unfinished generator to
destroy local stack variables so they can release allocated resources (RAII
pattern). The third argument of the generator constructor, `do_unwind`,
indicates whether the destructor should unwind the stack (unwind stack as default).

Stack unwinding assumes the following preconditions:

* The generator is not __not_a_gen__
* The generator is not complete
* The generator is not running
* The generator owns a stack

After unwinding, a __gen__ is complete.

[important You must not swallow __forced_unwind__ exceptions!]


[heading FPU preserving]

Some applications do not use floating-point registers and can disable preserving
fpu registers for perfromance reasons.

[note According to the ABIs the FPU registers are preserved by default.]


[section:generator Class `generator`]

    #include <boost/coroutine/generator.hpp>

    template< typename Result >
    class generator
    {
    public:
        class self_t
        {
        public:
            void yield( R);

            void yield_break();
        };

        generator();

        template<
            typename Fn,
            typename StackAllocator = ctx::stack_allocator,
            typename Allocator =std::alocator< generator >
        >
        generator( Fn fn, attributes const& attr = attributes(),
                   StackAllocator stack_alloc = StackAllocator(),
                   Allocator const& alloc = Allocator() ); 

        template<
            typename Fn,
            typename StackAllocator = ctx::stack_allocator,
            typename Allocator =std::alocator< generator >
        >
        generator( Fn && fn, attributes const& attr = attributes(),
                   StackAllocator stack_alloc = StackAllocator(),
                   Allocator const& alloc = Allocator() ); 

        generator( generator && other);

        generator & operator=( generator && other);

        operator unspecified-bool-type() const;

        bool operator!() const;

        void swap( generator & other);

        Result operator()();
    };

    void swap( generator & l, generator & r);

[heading `generator()`]
[variablelist
[[Effects:] [Creates a generator representing a __not_a_gen__.]]
[[Throws:] [Nothing.]]
]

[heading `template< typename Fn, typename StackAllocator, typename Allocator >
          generator( Fn fn, attributes const& attr, StackAllocator const& stack_alloc, Allocator const& alloc)`]
[variablelist
[[Preconditions:] [`size` > ctx::minimum_stacksize(), `size` < ctx::maximum_stacksize()
when ! ctx::is_stack_unbound().]]
[[Effects:] [Creates a generator which will execute `fn`. If the attribute
`attr` is iconstructed with `stack_unwind` the destructor of `*this` unwinds the
stack before destructing it. If `preserve_fpu` is `true` the floating-point
registers are preserved between context switches. For allocating/deallocating
the stack `stack_alloc` is used. For allocating internal data Allocator is used.]]
]

[heading `template< typename Fn, typename StackAllocator, typename Allocator >
          generator( Fn && fn, attributes const& attr, StackAllocator const& stack_alloc, Allocator const& alloc)`]
[variablelist
[[Preconditions:] [`size` > ctx::minimum_stacksize(), `size` < ctx::maximum_stacksize()
when ! ctx::is_stack_unbound().]]
[[Effects:] [Creates a generator which will execute `fn`. If the attribute
`attr` is iconstructed with `stack_unwind` the destructor of `*this` unwinds the
stack before destructing it. If `preserve_fpu` is `true` the floating-point
registers are preserved between context switches. For allocating/deallocating
the stack `stack_alloc` is used. For allocating internal data Allocator is used.]]
]

[heading `generator( generator && other)`]
[variablelist
[[Effects:] [Moves the internal data of `other` to `*this`.
`other` becomes __not_a_gen__.]]
[[Throws:] [Nothing.]]
]

[heading `generator & operator=( generator && other)`]
[variablelist
[[Effects:] [Destroys the internal data of `*this` and moves the
internal data of `other` to `*this`. `other` becomes __not_a_gen__.]]
[[Throws:] [Nothing.]]
]

[heading `operator unspecified-bool-type() const`]
[variablelist
[[Returns:] [If `*this` refers to __not_a_gen__, the function returns
false. Otherwise true.]]
[[Throws:] [Nothing.]]
]

[heading `bool operator!() const`]
[variablelist
[[Returns:] [If `*this` refers not to __not_a_gen__, the function returns
true. Otherwise false.]]
[[Throws:] [Nothing.]]
]

[heading `void swap( generator & other)`]
[variablelist
[[Effects:] [Swaps the internal data from `*this` with the values
of `other`.]]
[[Throws:] [Nothing.]]
]

[heading `Result operator()()`]
[variablelist
[[Preconditions:] [`*this` is not a __not_a_gen__, `! is_complete()`.]]
[[Effects:] [The return value is the argument passed to __gen_yield__.]] 
[[Throws:] [Re-throws exceptions exceptions thrown inside __gen_fn__.]]
]

[heading `void self_t::yield( Result)`]
[variablelist
[[Effects:] [Gives execution control back to calling context by returning
a value of type Result. The return type of this function is a __tuple__
containing the arguments passed to __gen_op__.]]
[[Throws:] [Nothing.]]
]

[heading `void self_t::yield_break()`]
[variablelist
[[Effects:] [Gives execution control back to calling context and sets the 
__gen__ to be complete. __gen_op__ in the other generator throws exception
__terminated_ex__.]]
[[Postconditions:] [`*this` is complete, which is `operator unspecified-bool-type()` returns
`false`.]]
]

[heading Non-member function `swap()`]

    void swap( generator & l, generator & r);

[variablelist
[[Effects:] [As if 'l.swap( r)'.]]
]

[endsect]

[endsect]
