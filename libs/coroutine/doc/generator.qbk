[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]

[section:generator Generator]

A __gen__ is a simple coroutine controling the iteration behaviour of a loop.
It generates a sequence of values, but instead of
returning them at once, a __gen__ behaves like an iterator yielding a values one
at the time if it is called.

Each instance of __gen__ represents a context (CPU registers and stack space) of
execution or __not_a_gen__. Objects of type __gen__ are moveable but not copyable
and can be returned by a function.

        boost::coro::generator< int > f();

        void f()
        {
            boost::coro::generator< int > c( f() );
            c();
        }

[warning If __gen__ is used in a multithreaded application, it can
migrated between threads, but must not reference __tls__.]

[note __boost_move__ is used to emulate rvalue references.]

[note If __fls__ is used on Windows, the user is responsible for calling 
__fls_alloc__, __fls_free__.]


[heading Executing a generator]

A new __gen__ is created from a callable object (known as the
__gen_fn__). The stack size, stack unwinding and floating-point
preserving behavior are determined by additional arguments.

The __gen__ constructor uses the __stack_allocator_concept__ from
__boost_context__ to allocate an associated stack, and the destructor uses the
same __stack_allocator_concept__ to deallocate the stack.  The default
__stack_allocator_concept__ is __stack_allocator__, but a custom stack-allocator
can be passed to the constructor (see documentation of __boost_context__).

The first argument of __gen_fn__  must be of type __gen_self__, used for yielding
the active generator.

        typedef boost::coro::generator< int > gen_t;

        void f( gen_t::caller_t & self)
        {
            ...
            self.yield( 11);
            ...
        }

        gen_t g( f);
        int y = g();

__gen_fn__ must return `void` and accept one parameter of type `__gen_self__`.
Use `boost::bind()` if it is required to passed additional parameters to
__gen_fn__ (bound by `boost::bind()`). If a reference is required,
use boost::ref.

Usally a __gen__ is called inside loops. The __gen_fn__ executed until
__gen_yield__ is called. The value passed to __gen_yield__ is used as the
generated value.
The next time the same __gen__ is called in a subsequent iteration, the
execution of the __gen_fn__ is resumed after __gen_yield__, until __gen_yield__
is called again.
__gen_fn__ can be terminated by __gen_yield_break__, at which time the loop
enclosing the __gen__ is terminated.

        typedef boost::coro::generator< int >    gen_t;

        void power( gen_t::caller_t & self, int number, int exponent)
        {
            int counter = 0, result = 1;
            while ( counter++ < exponent)
            {
                result = result * number;
                self.yield( result);
            }
        }

        int main()
        {
            {
                gen_t pw( boost::bind( power, _1, 2, 8) );
                while ( pw)
                    std::cout << pw() <<  " ";
            }

            std::cout << "\nDone" << std::endl;

            return EXIT_SUCCESS;
        }

        output:
            2 4 8 16 32 64 128 256
            Done


__gen_fn__ is invoked the first time inside the constructor of __gen__
(pre-fetching an retur nvalue).
__gen_op__ can be called as long as __gen__ remains valid (has an value to
return), e.g. __gen_eval__ returns `true`.

        typedef boost::coro::generator< int > gen_t;

        void fn( gen_t::caller_t & self, int j)
        {
            for( int i = 0; i < j; ++i)
            {
                std::cout << "fn(): local variable i == " << i << std::endl;

                // save current generator
                // value of local variable is preserved
                // transfer execution control back to main()
                self.yield( i);

                // generator<>::operator()() was called
                // execution control transfered back from main()    
            }
        }

        int main( int argc, char * argv[])
        {
            gen_t g( boost::bind( fn, _1, 7) );

            while ( g)
            {
                // execution control is transfered to g
                int x = g();
                std::cout << "main(): generated == " << x << std::endl;

                // yield() was called within fn()
            }

            std::cout << "Done" << std::endl;

            return EXIT_SUCCESS;
        }

        output:
            fn(): local variable i == 0
            main(): generated == 0
            fn(): local variable i == 1
            main(): generated == 1
            fn(): local variable i == 2
            main(): generated == 2
            fn(): local variable i == 3
            main(): generated == 3
            fn(): local variable i == 4
            main(): generated == 4
            fn(): local variable i == 5
            main(): generated == 5
            fn(): local variable i == 6
            main(): generated == 6
            Done

[warning Calling __gen_op__ from inside the same generator results in
undefined behaviour.]

[note In contrast to threads, which are preemtive, __gen__ switches are
cooperative (programmer controls when switch will happen). The kernel is not
involved in the generator switches.]


[heading Exceptions in __gen_fn__]

An excepton thrown inside __gen_fn__ (transfered via exception-pointer - see
__boost_exception__ for details and requirements) will be re-thrown by __gen_op__.

[important Code executed by generator must not prevent the propagation of the
__forced_unwind__ exception.  Absorbing that exception will cause stack
unwinding to fail.  Thus, any code that catches all exceptions must rethrow the
pending exception.]

        try
        {
            // code that might throw
        }
        catch( forced_unwind)
        {
            throw;
        }
        catch(...)
        {
            // possibly not rethrow pending exception
        }


[heading Stack unwinding]

Sometimes it is necessary to unwind the stack of an unfinished generator to
destroy local stack variables so they can release allocated resources (RAII
pattern). The third argument of the generator constructor, `do_unwind`,
indicates whether the destructor should unwind the stack (unwind stack as default).

Stack unwinding assumes the following preconditions:

* The generator is not __not_a_gen__
* The generator is not complete
* The generator is not running
* The generator owns a stack

After unwinding, a __gen__ is complete.

[important You must not swallow __forced_unwind__ exceptions!]


[heading FPU preserving]

Some applications do not use floating-point registers and can disable preserving
fpu registers for perfromance reasons.

[note According to the ABIs the FPU registers are preserved by default.]


[section:generator Class `generator`]

    #include <boost/coroutine/generator.hpp>

    template< typename R >
    class generator
    {
    public:
        class caller_t
        {
        public:
            void yield( R);
        };

        generator();

        template<
            typename Fn,
            typename StackAllocator = ctx::stack_allocator,
            typename Allocator =std::alocator< generator >
        >
        generator( Fn fn, attributes const& attr = attributes(),
                   StackAllocator stack_alloc = StackAllocator(),
                   Allocator const& alloc = Allocator() ); 

        template<
            typename Fn,
            typename StackAllocator = ctx::stack_allocator,
            typename Allocator =std::alocator< generator >
        >
        generator( Fn && fn, attributes const& attr = attributes(),
                   StackAllocator stack_alloc = StackAllocator(),
                   Allocator const& alloc = Allocator() ); 

        generator( generator && other);

        generator & operator=( generator && other);

        operator unspecified-bool-type() const;

        bool operator!() const;

        void swap( generator & other);

        R operator()();
    };

    void swap( generator & l, generator & r);

[heading `generator()`]
[variablelist
[[Effects:] [Creates a generator representing a __not_a_gen__.]]
[[Throws:] [Nothing.]]
]

[heading `template< typename Fn, typename StackAllocator, typename Allocator >
          generator( Fn fn, attributes const& attr, StackAllocator const& stack_alloc, Allocator const& alloc)`]
[variablelist
[[Preconditions:] [`size` > ctx::minimum_stacksize(), `size` < ctx::maximum_stacksize()
when ! ctx::is_stack_unbound().]]
[[Effects:] [Creates a generator which will execute `fn`. If the attribute
`attr` is iconstructed with `stack_unwind` the destructor of `*this` unwinds the
stack before destructing it. If `preserve_fpu` is `true` the floating-point
registers are preserved between context switches. For allocating/deallocating
the stack `stack_alloc` is used. For allocating internal data Allocator is used.]]
]

[heading `template< typename Fn, typename StackAllocator, typename Allocator >
          generator( Fn && fn, attributes const& attr, StackAllocator const& stack_alloc, Allocator const& alloc)`]
[variablelist
[[Preconditions:] [`size` > ctx::minimum_stacksize(), `size` < ctx::maximum_stacksize()
when ! ctx::is_stack_unbound().]]
[[Effects:] [Creates a generator which will execute `fn`. If the attribute
`attr` is iconstructed with `stack_unwind` the destructor of `*this` unwinds the
stack before destructing it. If `preserve_fpu` is `true` the floating-point
registers are preserved between context switches. For allocating/deallocating
the stack `stack_alloc` is used. For allocating internal data Allocator is used.]]
]

[heading `generator( generator && other)`]
[variablelist
[[Effects:] [Moves the internal data of `other` to `*this`.
`other` becomes __not_a_gen__.]]
[[Throws:] [Nothing.]]
]

[heading `generator & operator=( generator && other)`]
[variablelist
[[Effects:] [Destroys the internal data of `*this` and moves the
internal data of `other` to `*this`. `other` becomes __not_a_gen__.]]
[[Throws:] [Nothing.]]
]

[heading `operator unspecified-bool-type() const`]
[variablelist
[[Returns:] [If `*this` refers to __not_a_gen__, the function returns
false. Otherwise true.]]
[[Throws:] [Nothing.]]
]

[heading `bool operator!() const`]
[variablelist
[[Returns:] [If `*this` refers not to __not_a_gen__, the function returns
true. Otherwise false.]]
[[Throws:] [Nothing.]]
]

[heading `void swap( generator & other)`]
[variablelist
[[Effects:] [Swaps the internal data from `*this` with the values
of `other`.]]
[[Throws:] [Nothing.]]
]

[heading `R operator()()`]
[variablelist
[[Preconditions:] [`! is_complete()`.]]
[[Effects:] [The return value is the argument passed to __gen_yield__.]] 
[[Throws:] [Re-throws exceptions exceptions thrown inside __gen_fn__.]]
]

[heading `void caller_t::yield( R)`]
[variablelist
[[Effects:] [Gives execution control back to calling context by returning
a value of type R.]] 
[[Throws:] [Nothing.]]
]

[heading Non-member function `swap()`]

    void swap( generator & l, generator & r);

[variablelist
[[Effects:] [As if 'l.swap( r)'.]]
]

[endsect]

[endsect]
