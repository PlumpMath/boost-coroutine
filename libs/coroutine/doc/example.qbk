[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]

[section:example Example: input iterator]

This exmplae shows how a __coro__ is used together with an input stream and
__boost_asio__ in a service. The input stream reads its data from a TCP socket line by line,
e.g. the messages are delimetered by newline.

        class session : private boost::noncopyable
        {
        private:
            // handle input
            void handle_read_( coro_t::caller_t & self, boost::system::error_code const& ec, std::size_t n)
            {
                if ( ! ec)
                {
                    inbuf buf( socket_, coro_, self);
                    std::istream s( & buf);

                    std::string line;

                    // loop until we getan 'exit' message
                    do
                    {
                        // read message
                        std::getline( s, line);
                        // print message
                        std::cout << line << std::endl; 
                    } while ( line != "exit");
                }
                io_service_.post(
                    boost::bind(
                        & session::destroy_, this) );
            }

            void destroy_()
            { delete this; }

            coro_t                          coro_;
            boost::asio::io_service     &   io_service_;
            boost::asio::ip::tcp::socket    socket_;

        public:
            session( boost::asio::io_service & io_service) :
                // create coroutine executing handle_read_() as coroutine fucntion 
                coro_( boost::bind( & session::handle_read_, this, _1, _2, _3) ),
                io_service_( io_service),
                socket_( io_service_)
            { std::cout << "serivce()" << std::endl; }

            ~session()
            { std::cout << "~serivce()" << std::endl; }

            boost::asio::ip::tcp::socket & socket()
            { return socket_; }

            void start()
            { coro_( boost::system::error_code(), 0); }
        };

Class `session` is created by server (acceptor) ifor each connection request and
handles the communication with the client. __io_svc__ dispatches to a `session` instance
if bytes are available in the socket buffer. Each message is read via `getline()` from
the input stream. If no more bytes can be read from the socket and the last byte was not
an newline char the application would usally block inside `getline()` (== inside
`underflow()` of the stream buffer).

With the help of a __coro__ the application can jump to __io_svc__ in order to dispatch other
event until additional bytes can be read from the socket.

        class inbuf : public std::streambuf,
                      private boost::noncopyable
        {
        private:
            static const std::streamsize        pb_size;

            enum
            { bf_size = 16 };

            std::size_t fetch_()
            {
                std::streamsize num = std::min(
                    static_cast< std::streamsize >( gptr() - eback() ), pb_size);

                std::memmove(
                    buffer_ + ( pb_size - num),
                    gptr() - num, num);

                // request to read some bytes from socket
                // coroutine will be resumed() in callback after
                // some bytes are available in the socket buffer
                s_.async_read_some(
                        boost::asio::buffer( buffer_ + pb_size, bf_size - pb_size),
                        boost::bind( & coro_t::operator(), & coro_, _1, _2) );
                // yield this coroutine function == jumping back to io_service
                tuple_t tpl = self_.yield();
                // coroutine was resumend by io_service
                // because some bytes can be read from socket buffer
                boost::system::error_code ec = tpl.get< 0 >();
                std::size_t n = tpl.get< 1 >();
                if ( ec)
                {
                    // error
                    setg( 0, 0, 0);
                    return -1;
                }

                // adjust pointers in stream buffer
                setg( buffer_ + pb_size - num, buffer_ + pb_size, buffer_ + pb_size + n);
                return n;
            }

            boost::asio::ip::tcp::socket    &   s_;
            coro_t                          &   coro_;
            coro_t::caller_t                  &   self_;
            char                                buffer_[bf_size];

        protected:
            virtual int underflow()
            {
                if ( gptr() < egptr() )
                    return traits_type::to_int_type( * gptr() );

                if ( 0 > fetch_() )
                    return traits_type::eof();
                else
                    return traits_type::to_int_type( * gptr() );
            }

        public:
            inbuf(
                    boost::asio::ip::tcp::socket & s,
                    coro_t & coro,
                    coro_t::caller_t & self) :
                s_( s), coro_( coro), self_( self), buffer_()
            { setg( buffer_ + 4, buffer_ + 4, buffer_ + 4); }
        };
        const std::streamsize inbuf::pb_size = 4;

In `_fetch()` called by public function `underflow()` an read request is send to __io_svc__ with
a callback executing a jump to this coroutine. After this read request was send the __coro__ is
suspended by calling `yield()`. Ifsome bytes arrived in the socker buffer __io_svc__ calls the
callback and resumes the coroutine. The stream can read the arrived bytes from the socket and
returns from `getline()` if a newline was in the bytes sequence.

[endsect]
