[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]

[section:coroutine Coroutine]

Each instance of __coro__ has its own context of execution (CPU registers and
stack space) or represents __not_a_coro__ (similiar to __thread__).
Objects of type __coro__ are moveable but not copyable and can be returned by a
function.

        boost::coro::coroutine< void() > f();

        void g()
        {
            boost::coro::coroutine< void() > c( f() );
            c();
        }

[note __boost_move__ is used to emulate rvalue references.]


[heading Creating a coroutine]

A new __coro__ is created from a __coro_fn__ (function or functor) which will be
executed in a new __ctx__ (CPU registers and stack space).

[note __coro_fn__ is required to return ['void] and accept a reference of type
__coro_caller__.]

The template argument __signature__ determines the data-types transfered to
__coro_fn__ and from __coro_fn__ by calling __coro_op__ and __coro_get___.

        typedef boost::coro::coroutine< int( std::string const&) > coro_t;

        void f( coro_t::caller_type & ca)
        {
            ...
            std::string str( ca.get() ); // argument
            ...
            ca( 7);
            ...
        }

        std::string str;
        ...
        coro_t c( f);
        c( str); // argument
        int res = c.get(); // returned value


The __coro_fn__ is started at __coro__ construction (similiar to __thread__)
in a newly created __coro__ complete with registers, flags, stack and
instruction pointer.
If __coro_fn__ requires some parameters (types defined by __signature__)
on startup those parameters must be applied to the __coro__ constructor.

        typedef boost::coro::coroutine< int( std::string const&) > coro_t;

        void f( coro_t::caller_type & ca);

        std::string str;
        coro_t c( f, str);


(multiple arguments)

        typedef boost::coro::coroutine< int( int, std::string const&) > coro_t;

        void f( coro_t::caller_type & ca);

        std::string str("abc");
        coro_t c( f, coro_t::arguments( 7, str) );


[note The maximum number of arguments of __coro_fn__ is limited to 10 (limit
defined by __boost_tuple__).]

__attrs__, an additional constructor argument of __coro__, defines the stack
size, stack unwinding and floating-point preserving behavior used for __ctx__
construction.

The __coro__ constructor uses the __stack_allocator_concept__ from
__boost_context__ to allocate an associated stack, and the destructor uses the
same __stack_allocator_concept__ to deallocate the stack.  The default
__stack_allocator_concept__ is __stack_allocator__ (see documentation of
__boost_context__), but a custom stack-allocator can be passed to the
constructor.


[heading Calling a coroutine]

When control should be returned to the original calling routine, call __coro_op__
of __coro_fn__ only argument.
The current coroutine information (registers, flags, and stack and instruction
pointer) is saved and the original context information is restored. Calling
__coro_op__ resumes execution in the coroutine after saving the new state of the
original routine.

        typedef boost::coro::coroutine< void() > coro_t;

        void fn( coro_t::caller_type & ca, int j)
        {
            for( int i = 0; i < j; ++i)
            {
                std::cout << "fn(): local variable i == " << i << std::endl;

                // save current coroutine
                // value of local variable is preserved
                // transfer execution control back to main()
                ca();

                // coroutine<>::operator()() was called
                // execution control transfered back from main()
            }
        }

        int main( int argc, char * argv[])
        {
            coro_t c( boost::bind( fn, _1, 7) );

            std::cout << "main() starts coroutine c" << std::endl;

            while ( c)
            {
                std::cout << "main() calls coroutine c" << std::endl;
                // execution control is transfered to c
                c();
            }

            std::cout << "Done" << std::endl;

            return EXIT_SUCCESS;
        }

        output:
            main() starts coroutine c
            fn(): local variable i == 0
            main() calls coroutine c
            fn(): local variable i == 1
            main() calls coroutine c
            fn(): local variable i == 2
            main() calls coroutine c
            fn(): local variable i == 3
            main() calls coroutine c
            fn(): local variable i == 4
            main() calls coroutine c
            fn(): local variable i == 5
            main() calls coroutine c
            fn(): local variable i == 6
            main() calls coroutine c
            Done

[warning Calling __coro_op__ from inside the same coroutine results in
undefined behaviour.]


[heading Transfer of data]

The first template argument of __coro__, __signature__, defines the signature of
the __coro_fn__ and its return type.

[note __coro_self__ is not part of __signature__ and is always expected to be the first
argument of __coro_fn__.]

__coro_op__  accepts arguments as defined in __signature__ and has the same return
type. The arguments passed to __coro_op__, in one coroutine, is returned
(as a boost::tuple) by __coro_yield__
in the other coroutine or, if it is the first call to __coro_op__ (__coro__ was not
started), the __coro_fn__ will be entered and the arguments are passed to __coro_fn__
on entry.

The value given to __coro_yield__, in one coroutine, is returned by __coro_op__ in
the other routine. 

        typedef boost::coro::coroutine< int( int) >    coro_t;

        int fn( coro_t::caller_type & self, int i)
        {
            std::cout << "fn(): local variable i == " << i << std::endl;

            // save current coroutine context
            // transfer execution control back to caller
            // pass content of variable back
            int j = self.yield( i);
            // j == 10 because c( 10) in main()
            std::cout << "fn(): local variable j == " << j << std::endl;

            return j;
        }

        int main( int argc, char * argv[])
        {
            coro_t c( boost::bind( fn, _1, _2) );

            std::cout << "main(): call coroutine c" << std::endl;

            int x = c( 7);
            std::cout << "main(): transfered value: " << x << std::endl;

            x = c( 10);
            std::cout << "main(): transfered value: " << x << std::endl;

            std::cout << "Done" << std::endl;

            return EXIT_SUCCESS;
        }

        output:
            main(): call coroutine c
            fn(): local variable i == 7
            main(): transfered value: 7
            fn(): local variable j == 10
            main(): transfered value: 10
            Done


[heading __coro_fn__ with multiple arguments]

If __coro_fn__ has more than one argument __coro_op__ has the same size of
arguments and __coro_yield__ returns a ['boost::tuple] coresponding to the
arguments of __signature__.

        typedef boost::coro::coroutine< int(int,int) > coro_t;

        int fn( coro_t::caller_type & self, int a, int b)
        {
            int tmp = a + b;
            boost::tuple< int, int > ret = self.yield( tmp);
            return ret.get< 0 >() + ret.get< 1 >();
        }

        int main( int argc, char * argv[])
        {
            coro_t coro( boost::bind( fn, _1, _2, _3) );

            std::cout << "main(): call coroutine c" << std::endl;
            int res = coro( 3, 7);
            std::cout << "main(): 3 + 7 == " << res << std::endl;

            res = coro( 5, 7);
            std::cout << "main(): 5 + 7 == " << res << std::endl;

            std::cout << "Done" << std::endl;

            return EXIT_SUCCESS;
        }

        output:
            main(): call coroutine c
            main(): 3 + 7 == 10
            main(): 5 + 7 == 12
            Done

[heading Exit a __coro_fn__]

__coro_yield_break__ does not take arguments and returns nothing, it leaves the
current __coro__ and jumps back to the calling routine throwing an exception of
type __terminated_ex__. 

        typedef boost::coro::coroutine< int(int,int) > coro_t;

        int fn( coro_t::caller_type & self, int a, int b)
        {
            int tmp = a + b;
            boost::tuple< int, int > ret = self.yield( tmp);
            self.yield_break();
            return -1;
        }

        int main( int argc, char * argv[])
        {
            try
            {
                coro_t coro( boost::bind( fn, _1, _2, _3) );

                std::cout << "main(): call coroutine c" << std::endl;
                int res = coro( 3, 7);
                std::cout << "main(): 3 + 7 == " << res << std::endl;

                res = coro( 5, 7);
                std::cout << "main(): 5 + 7 == " << res << std::endl;

                std::cout << "Done" << std::endl;

                return EXIT_SUCCESS;
            }
            catch ( boost::coro::coroutine_terminated const&)
            { std::cerr << "coroutine terminated" << std::endl; }

            return EXIT_FAILURE;
        }

        output:
            main(): call coroutine c
            main(): 3 + 7 == 10
            coroutine terminated

[important After calling __coro_yield_break__ the __coro__ is complete (can not
resumed with __coro_op__).]


[heading Exceptions in __coro_fn__]

An exception thrown inside __coro_fn__ (transfered via exception-pointer - see
__boost_exception__ for details and requirements) will be re-thrown by __coro_op__.
If the thrown exception does not follow the guidlines from __boost_exception__
an exception of type  `unknown_exception` will be re-thrown.

[important Code executed by coroutine must not prevent the propagation of the
__forced_unwind__ exception.  Absorbing that exception will cause stack
unwinding to fail.  Thus, any code that catches all exceptions must rethrow the
pending exception.]

        try
        {
            // code that might throw
        }
        catch( forced_unwind)
        {
            throw;
        }
        catch(...)
        {
            // possibly not rethrow pending exception
        }


[heading Stack unwinding]

Sometimes it is necessary to unwind the stack of an unfinished coroutine to
destroy local stack variables so they can release allocated resources (RAII
pattern). The third argument of the coroutine constructor, `do_unwind`,
indicates whether the destructor should unwind the stack (stack is unwound by
default).

Stack unwinding assumes the following preconditions:

* The coroutine is not __not_a_coro__
* The coroutine is not complete
* The coroutine is not running
* The coroutine owns a stack

After unwinding, a __coro__ is complete.


        typedef boost::coro::coroutine< void() >    coro_t;

        struct X
        {
            X()
            { std::cout << "X()" << std::endl; }

            ~X()
            { std::cout << "~X()" << std::endl; }
        };

        void fn()
        {
            X x;

            for( int i = 0;; ++i)
            {
                std::cout << "fn(): " << i << std::endl;
                // transfer execution control back to main()
                self.yield();
            }
        }

        int main( int argc, char * argv[])
        {
            {
                coro_t c( boost::bind( fn, _1),
                          boost::coro::attributes(
                            boost::ctx::default_stacksize(),
                            boost::coro::stack_unwind) );
                for ( int i = 0; i < 5; ++i)
                {
                    // transfer execution control to fn()
                    c();
                }

                std::cout << "c is complete: " << std::boolalpha << c.is_complete() << "\n";
            }

            std::cout << "Done" << std::endl;

            return EXIT_SUCCESS;
        }

        output:
            X()
            fn(): 0
            fn(): 1
            fn(): 2
            fn(): 3
            fn(): 4
            fn(): 5
            c is complete: false
            ~X()
            Done

[important You must not swallow __forced_unwind__ exceptions!]


[heading FPU preserving]

Some applications do not use floating-point registers and can disable preserving
fpu registers for performance reasons.

[note According to the ABIs the FPU registers are preserved by default.]


[section:coroutine Class `coroutine`]

    #include <boost/coroutine/coroutine.hpp>

    template<
        typename Signature,
        typename StackAllocator = ctx::stack_allocator
    >
    class coroutine;

    template<
        typename R,
        typename ArgTypes...
    >
    class coroutine< R ( ArgTypes...)>
    {
    public:
        class caller_type
        {
        public:
            tuple< ArgTypes... > yield( R);

            void yield_break();
        };

        coroutine();

        template<
            typename Fn,
            typename StackAllocator = ctx::stack_allocator,
            typename Allocator =std::alocator< generator >
        >
        coroutine( Fn fn, attributes const& attr = attributes(),
                   StackAllocator const& stack_alloc = StackAllocator(),
                   Allocator const& alloc = Allocator() );

        template<
            typename Fn,
            typename StackAllocator = ctx::stack_allocator,
            typename Allocator =std::alocator< generator >
        >
        coroutine( Fn && fn, attributes const& attr = attributes(),
                   StackAllocator stack_alloc = StackAllocator(),
                   Allocator const& alloc = Allocator() );

        coroutine( coroutine && other);

        coroutine & operator=( coroutine && other);

        operator unspecified-bool-type() const;

        bool operator!() const;

        void swap( coroutine & other);

        bool is_complete() const;

        R operator()(A0 a0, ..., A9 a9);
    };

    void swap( coroutine & l, coroutine & r);

[heading `coroutine()`]
[variablelist
[[Effects:] [Creates a coroutine representing a __not_a_coro__.]]
[[Throws:] [Nothing.]]
]

[heading `template< typename Fn, typename StackAllocator, typename Allocator >
          coroutine( Fn fn, attributes const& attr, StackAllocator const& stack_alloc, Allocator const& alloc)`]
[variablelist
[[Preconditions:] [`size` > ctx::minimum_stacksize(), `size` < ctx::maximum_stacksize()
when ! ctx::is_stack_unbound().]]
[[Effects:] [Creates a coroutine which will execute `fn`. If the attribute
`attr` is constructed with `stack_unwind` the destructor of `*this` unwinds the
stack before destructing it. If `preserve_fpu` is `true` the floating-point
registers are preserved between context switches. For allocating/deallocating
the stack `stack_alloc` is used. For allocating internal data Allocator is used.]]
]

[heading `template< typename Fn, typename StackAllocator, typename Allocator >
          coroutine( Fn && fn, attributes const& attr, StackAllocator const& stack_alloc, Allocator const& alloc)`]
[variablelist
[[Preconditions:] [`size` > ctx::minimum_stacksize(), `size` < ctx::maximum_stacksize()
when ! ctx::is_stack_unbound().]]
[[Effects:] [Creates a coroutine which will execute `fn`. If the attribute
`attr` is constructed with `stack_unwind` the destructor of `*this` unwinds the
stack before destructing it. If `preserve_fpu` is `true` the floating-point
registers are preserved between context switches. For allocating/deallocating
the stack `stack_alloc` is used. For allocating internal data Allocator is used.]]
]

[heading `coroutine( coroutine && other)`]
[variablelist
[[Effects:] [Moves the internal data of `other` to `*this`.
`other` becomes __not_a_coro__.]]
[[Throws:] [Nothing.]]
]

[heading `coroutine & operator=( coroutine && other)`]
[variablelist
[[Effects:] [Destroys the internal data of `*this` and moves the
internal data of `other` to `*this`. `other` becomes __not_a_coro__.]]
[[Throws:] [Nothing.]]
]

[heading `operator unspecified-bool-type() const`]
[variablelist
[[Returns:] [If `*this` refers to __not_a_coro__, the function returns
false. Otherwise true.]]
[[Throws:] [Nothing.]]
]

[heading `bool operator!() const`]
[variablelist
[[Returns:] [If `*this` refers not to __not_a_coro__, the function returns
true. Otherwise false.]]
[[Throws:] [Nothing.]]
]

[heading `void swap( coroutine & other)`]
[variablelist
[[Effects:] [Swaps the internal data from `*this` with the values
of `other`.]]
[[Throws:] [Nothing.]]
]

[heading `bool is_complete() const`]
[variablelist
[[Preconditions:] [`*this` is not a __not_a_coro__.]]
[[Effects:] [Returns `true` if coroutine-function of `*this` has returned.]]
[[Throws:] [Nothing.]]
]

[heading `R operator()(A0 a0, A9 a9)`]
[variablelist
[[Preconditions:] [`*this` is not a __not_a_coro__, `! is_complete()`.]]
[[Effects:] [__coro_fn__ is entered and the arguments are passed to the
__coro__. The return value is the argument passed to __coro_yield__.]] 
[[Throws:] [__terminated_ex__ if __coro_yield_break__ was called or other
exceptions thrown inside __coro_fn__.]]
]

[heading `T caller_type::yield( R)`]
[variablelist
[[Effects:] [Gives execution control back to calling context by returning
a value of type R. The return type of this function is a __tuple__ containing
the arguments passed to __coro_op__.]]
[[Throws:] [Nothing.]]
]

[heading `void caller_type::yield_break()`]
[variablelist
[[Effects:] [Gives execution control back to calling context and sets the 
__coro__ to be complete. __coro_op__ in the other coroutine throws exception
__terminated_ex__.]]
[[Postconditions:] [`*this` is complete, which is `is_complete()` returns
`true`.]]
]

[heading Non-member function `swap()`]

    void swap( coroutine & l, coroutine & r);

[variablelist
[[Effects:] [As if 'l.swap( r)'.]]
]

[endsect]

[include example.qbk]

[endsect]
